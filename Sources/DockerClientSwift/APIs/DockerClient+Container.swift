import Foundation
import NIO
import AsyncHTTPClient

extension DockerClient {
    
    /// APIs related to containers.
    public var containers: ContainersAPI {
        .init(client: self)
    }
    
    public struct ContainersAPI {
        fileprivate var client: DockerClient
        
        /// Fetches all containers in the Docker system.
        /// - Parameter all: If `true` all containers are fetched, otherwise only running containers.
        /// - Throws: Errors that can occur when executing the request.
        /// - Returns: Returns a list of `Container`.
        public func list(all: Bool = false) async throws -> [ContainerSummary] {
            return try await client.run(ListContainersEndpoint(all: all))
        }
        
        /// Creates a new container from a given image. If specified the commands override the default commands from the image.
        /// - Parameters:
        ///   - image: Instance of an `Image`.
        ///   - commands: Override the default commands from the image. Default `nil`.
        /// - Throws: Errors that can occur when executing the request.
        /// - Returns: Returns  the created `Container` Id.
        public func create(image: Image, commands: [String]? = nil) async throws -> String {
            let response = try await client.run(SimpleCreateContainerEndpoint(imageName: image.id.value, commands: commands))
            return response.Id
        }
        
        /// Creates a new container from a fully customizable config.
        /// - Parameters:
        ///   - name:  Custom name for this container. If not set, a random one will be generated by Docker. Must match `/?[a-zA-Z0-9][a-zA-Z0-9_.-]+` (must start with a letter or number, then must only contain letters, numbers, _, ., -)
        ///   - spec: Configuration
        /// - Returns: Returns  the created `Container` Id.
        public func create(name: String? = nil, spec: ContainerCreate) async throws -> String {
            let response = try await client.run(CreateContainerEndpoint(name: name, spec: spec))
            return response.Id
        }
        
        /// Starts a container. Before starting it needs to be created.
        /// - Parameter nameOrId: Name or Id of the`Container`.
        /// - Throws: Errors that can occur when executing the request.
        public func start(_ nameOrId: String) async throws {
            try await client.run(StartContainerEndpoint(containerId: nameOrId))
        }
        
        /// Stops a container. Before stopping it needs to be created and started..
        /// - Parameter nameOrId: Name or Id of the`Container`.
        /// - Throws: Errors that can occur when executing the request.
        public func stop(_ nameOrId: String) async throws {
            try await client.run(StopContainerEndpoint(containerId: nameOrId))
        }
        
        /// Removes an existing container.
        /// - Parameters:
        ///   - nameOrId: Name or Id of the`Container`.
        ///   - force: Delete even if it is running
        ///   - removeAnonymousVolumes: Remove anonymous volumes associated with the container.
        /// - Throws: Errors that can occur when executing the request.
        public func remove(_ nameOrId: String, force: Bool = false, removeAnonymousVolumes: Bool = false) async throws {
            try await client.run(RemoveContainerEndpoint(containerId: nameOrId, force: force, removeAnonymousVolumes: removeAnonymousVolumes))
        }
        
        /// Gets the logs of a container.
        /// - Parameters:
        ///   - container: Instance of an `Container`.
        ///   - stdErr: whether to return log lines from the standard error.
        ///   - stdOut: whether to return log lines from the standard output.
        ///   - timestamps: whether to return the timestamp of each log line
        ///   - follow: whether to wait for new logs to become available and stream them.
        ///   - tail: number of last existing log lines to return. Default: all.
        /// - Throws: Errors that can occur when executing the request.
        /// - Returns: Returns  a  sequence of `LogEntry`.
        public func logs(container: Container, stdErr: Bool = true, stdOut: Bool = true, timestamps: Bool = true, follow: Bool = false, tail: UInt? = nil, since: Date = .distantPast, until: Date = .distantFuture) async throws -> AsyncThrowingStream<DockerLogEntry, Error> {
            let response = try await client.run(
                GetContainerLogsEndpoint(
                    containerId: container.id,
                    stdout: stdOut,
                    stderr: stdErr,
                    timestamps: timestamps,
                    follow: follow,
                    tail: tail == nil ? "all" : "\(tail!)",
                    since: since,
                    until: until
                ),
                // Arbitrary timeouts.
                // TODO: should probably make these configurable
                timeout: follow ? .hours(12) : .seconds(30)
            )
            
            let format = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSS'Z'"
            let formatter = DateFormatter()
            formatter.dateFormat = format
            
            return AsyncThrowingStream<DockerLogEntry, Error> { continuation in
                Task {
                    for try await var buffer in response {
                        let totalDataSize = buffer.readableBytes
                        while buffer.readerIndex < totalDataSize {
                            if buffer.readableBytes == 0 {
                                continuation.finish()
                            }
                            if container.config.tty {
                                do {
                                    for entry in try getEntryTty(buffer: &buffer, timestamps: timestamps, formatter: formatter) {
                                        continuation.yield(entry)
                                    }
                                }
                                catch(let error) {
                                    continuation.finish(throwing: error)
                                    return
                                }
                            }
                            else {
                                do {
                                    let entry = try getEntryNoTty(buffer: &buffer, timestamps: timestamps, formatter: formatter)
                                    continuation.yield(entry)
                                }
                                catch (let error) {
                                    continuation.finish(throwing: error)
                                    return
                                }
                                
                            }
                        }
                    }
                    continuation.finish()
                }
            }
        }
        
        /// Extracts a log entry/line for a container not having a TTY
        private func getEntryNoTty(buffer: inout ByteBuffer, timestamps: Bool, formatter: DateFormatter) throws -> DockerLogEntry {
            let timestampLen = timestamps ? 31 : 0

            guard let sourceRaw: UInt8 = buffer.readInteger(endianness: .big, as: UInt8.self) else {
                throw DockerLogDecodingError.dataCorrupted("Unable to read log entry source stream header")
            }
            let msgSource = DockerLogEntry.Source.init(rawValue: sourceRaw) ?? .stdout
            let _ = buffer.readBytes(length: 3) // 3 unused bytes
            
            guard let msgSize: UInt32 = buffer.readInteger(endianness: .big, as: UInt32.self) else {
                throw DockerLogDecodingError.dataCorrupted("Unable to read log size header")
            }
            
            guard msgSize > 0 else {
                throw DockerLogDecodingError.noMessageFound
            }
            if buffer.readableBytes < msgSize {
                // TODO: does this happen during normal logs streaming behavior?
                throw DockerLogDecodingError.dataCorrupted("Readable bytes (\(buffer.readableBytes) are less than msgSize (\(msgSize))")
            }
            
            var timestamp: Date? = nil
            var msgBuffer = ByteBuffer.init(bytes: buffer.readBytes(length: Int(msgSize))!)
            if timestamps {
                guard let timestampRaw = msgBuffer.readString(length: timestampLen, encoding: .utf8) else {
                    throw DockerLogDecodingError.noTimestampFound
                }
                guard let timestampTry = formatter.date(from: String(timestampRaw)) else {
                    throw DockerLogDecodingError.timestampCorrupted
                }
                timestamp = timestampTry
            }
            guard let message = msgBuffer.readString(length: msgBuffer.readableBytes - 1, encoding: .utf8) else {
                throw  DockerLogDecodingError.dataCorrupted("Unable to parse log message as String")
            }
            
            return DockerLogEntry(source: msgSource, timestamp: timestamp, message: message)
        }
        
        /// Extracts a log entry/line for a container having a TTY
        private func getEntryTty(buffer: inout ByteBuffer, timestamps: Bool, formatter: DateFormatter) throws -> [DockerLogEntry] {
            let timestampLen = timestamps ? 31 : 0
            //let data = Data(buffer: buffer)
            let data = buffer.readData(length: buffer.readableBytes)!
            let lines = data.split(separator: 10 /* ascii code for \n */)
            var logEntries: [DockerLogEntry] = []
            for line in lines {
                var timestamp: Date? = nil
                var msgBuffer = ByteBuffer(data: line)
                if timestamps {
                    guard let timestampRaw = msgBuffer.readString(length: timestampLen, encoding: .utf8) else {
                        throw DockerLogDecodingError.noTimestampFound
                    }
                    guard let timestampTry = formatter.date(from: String(timestampRaw)) else {
                        throw DockerLogDecodingError.timestampCorrupted
                    }
                    timestamp = timestampTry
                }
                guard let message = msgBuffer.readString(length: msgBuffer.readableBytes - 1, encoding: .utf8) else {
                    throw  DockerLogDecodingError.dataCorrupted("Unable to parse log message as String")
                }
                
                logEntries.append(
                    DockerLogEntry(source: .stdout, timestamp: timestamp, message: message)
                )
            }
            return logEntries
        }
        
        /// Fetches the latest information about a container by a given name or id..
        /// - Parameter nameOrId: Name or id of a container.
        /// - Throws: Errors that can occur when executing the request.
        /// - Returns: Returns the `Container` and its information.
        public func get(_ nameOrId: String) async throws -> Container {
            return try await client.run(InspectContainerEndpoint(nameOrId: nameOrId))
        }
        
        
        /// Deletes all stopped containers.
        /// - Throws: Errors that can occur when executing the request.
        /// - Returns: Returns an `EventLoopFuture` with a list of deleted `Container` and the reclaimed space.
        public func prune() async throws -> PrunedContainers {
            let response =  try await client.run(PruneContainersEndpoint())
            return PrunedContainers(
                containersIds: response.ContainersDeleted?.map({ .init($0)}) ?? [],
                reclaimedSpace: response.SpaceReclaimed
            )
        }
        
        public struct PrunedContainers {
            /// IDs of the containers that were deleted.
            let containersIds: [String]
            
            /// Disk space reclaimed in bytes.
            let reclaimedSpace: UInt64
        }
    }
}

