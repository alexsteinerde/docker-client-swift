import Foundation
import NIO
import AsyncHTTPClient

extension DockerClient {
    
    /// APIs related to containers.
    public var containers: ContainersAPI {
        .init(client: self)
    }
    
    public struct ContainersAPI {
        fileprivate var client: DockerClient
        
        /// Fetches all containers in the Docker system.
        /// - Parameter all: If `true` all containers are fetched, otherwise only running containers.
        /// - Throws: Errors that can occur when executing the request.
        /// - Returns: Returns a list of `Container`.
        public func list(all: Bool = false) async throws -> [ContainerSummary] {
            return try await client.run(ListContainersEndpoint(all: all))
        }
        
        /// Creates a new container from a given image. If specified the commands override the default commands from the image.
        /// - Parameters:
        ///   - image: Instance of an `Image`.
        ///   - commands: Override the default commands from the image. Default `nil`.
        /// - Throws: Errors that can occur when executing the request.
        /// - Returns: Returns  the created `Container` Id.
        public func create(image: Image, commands: [String]? = nil) async throws -> String {
            let response = try await client.run(SimpleCreateContainerEndpoint(imageName: image.id.value, commands: commands))
            return response.Id
        }
        
        /// Creates a new container from a fully customizable config.
        /// - Parameters:
        ///   - name:  Custom name for this container. If not set, a random one will be generated by Docker. Must match `/?[a-zA-Z0-9][a-zA-Z0-9_.-]+` (must start with a letter or number, then must only contain letters, numbers, _, ., -)
        ///   - spec: Configuration
        /// - Returns: Returns  the created `Container` Id.
        public func create(name: String? = nil, spec: ContainerCreate) async throws -> String {
            let response = try await client.run(CreateContainerEndpoint(name: name, spec: spec))
            return response.Id
        }
        
        /// Starts a container. Before starting it needs to be created.
        /// - Parameter nameOrId: Name or Id of the`Container`.
        /// - Throws: Errors that can occur when executing the request.
        public func start(_ nameOrId: String) async throws {
            try await client.run(StartContainerEndpoint(containerId: nameOrId))
        }
        
        /// Stops a container. Before stopping it needs to be created and started..
        /// - Parameter nameOrId: Name or Id of the`Container`.
        /// - Throws: Errors that can occur when executing the request.
        public func stop(_ nameOrId: String) async throws {
            try await client.run(StopContainerEndpoint(containerId: nameOrId))
        }
        
        /// Removes an existing container.
        /// - Parameters:
        ///   - nameOrId: Name or Id of the`Container`.
        ///   - force: Delete even if it is running
        ///   - removeAnonymousVolumes: Remove anonymous volumes associated with the container.
        /// - Throws: Errors that can occur when executing the request.
        public func remove(_ nameOrId: String, force: Bool = false, removeAnonymousVolumes: Bool = false) async throws {
            try await client.run(RemoveContainerEndpoint(containerId: nameOrId, force: force, removeAnonymousVolumes: removeAnonymousVolumes))
        }
        
        /// Gets the logs of a container.
        /// - Parameters:
        ///   - container: Instance of an `Container`.
        ///   - stdErr: whether to return log lines from the standard error.
        ///   - stdOut: whether to return log lines from the standard output.
        ///   - timestamps: whether to return the timestamp of each log line
        ///   - follow: whether to wait for new logs to become available and stream them.
        ///   - tail: number of last existing log lines to return. Default: all.
        /// - Throws: Errors that can occur when executing the request.
        /// - Returns: Returns  a  sequence of `LogEntry`.
        public func logs(container: Container, stdErr: Bool = true, stdOut: Bool = true, timestamps: Bool = true, follow: Bool = false, tail: UInt? = nil, since: Date = .distantPast, until: Date = .distantFuture) async throws -> AsyncThrowingStream<DockerLogEntry, Error> {
            let response = try await client.run(
                GetContainerLogsEndpoint(
                    containerId: container.id,
                    stdout: stdOut,
                    stderr: stdErr,
                    timestamps: timestamps,
                    follow: follow,
                    tail: tail == nil ? "all" : "\(tail!)",
                    since: since,
                    until: until
                ),
                // Arbitrary timeouts.
                // TODO: should probably make these configurable
                timeout: follow ? .hours(24) : .seconds(30)
            )
            
            let format = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSS'Z'"
            let timestampLen = timestamps ? 31 : 0//format.count
            let formatter = DateFormatter()
            formatter.dateFormat = format
            
            return AsyncThrowingStream<DockerLogEntry, Error> { continuation in
                Task {
                    for try await var buffer in response {
                        var timestamp = Date.distantPast
                        let totalDataSize = buffer.readableBytes
                        
                        while buffer.readerIndex < totalDataSize {
                            if buffer.readableBytes == 0 {
                                continuation.finish()
                            }
                            
                            // Each Log/Stream message is prefixed with an 8 bytes header
                            guard let sourceRaw: UInt8 = buffer.readInteger(endianness: .big, as: UInt8.self) else {
                                continuation.finish(throwing: DockerLogDecodingError.dataCorrupted)
                                return
                            }
                            let _ = buffer.readBytes(length: 3) // 3 unused bytes
                            guard let msgSize: UInt32 = buffer.readInteger(endianness: .big, as: UInt32.self) else {
                                continuation.finish(throwing: DockerLogDecodingError.dataCorrupted)
                                return
                            }
                            
                            guard msgSize > 0 else {
                                continuation.finish(throwing: DockerLogDecodingError.noMessageFound)
                                return
                            }
                            if buffer.readableBytes < msgSize {
                                // TODO: does this happen during normal logs streaming behavior?
                                print("\nðŸ’£ðŸ’£ðŸ’£ðŸ’£ðŸ’£ðŸ’£ readable bytes are less than msgSize!")
                                continuation.finish(throwing: DockerLogDecodingError.dataCorrupted)
                                return
                            }
                            
                            var msgBuffer = ByteBuffer.init(bytes: buffer.readBytes(length: Int(msgSize))!)
                            if timestamps {
                                guard let timestampRaw = msgBuffer.readString(length: timestampLen, encoding: .utf8) else {
                                    continuation.finish(throwing: DockerLogDecodingError.noTimestampFound)
                                    return
                                }
                                guard let timestampTry = formatter.date(from: String(timestampRaw)) else {
                                    continuation.finish(throwing: DockerLogDecodingError.timestampCorrupted)
                                    return
                                }
                                timestamp = timestampTry
                            }
                            guard let message = msgBuffer.readString(length: Int(msgSize - UInt32(timestampLen)), encoding: .utf8) else {
                                continuation.finish(throwing: DockerLogDecodingError.dataCorrupted)
                                return
                            }
                            
                            continuation.yield(
                                DockerLogEntry(
                                    source: DockerLogEntry.Source.init(rawValue: sourceRaw) ?? .stdout,
                                    timestamp: timestamp,
                                    message: message
                                )
                            )
                        }
                    }
                    
                    continuation.finish()
                }
            }
        }
        
        
        /// Fetches the latest information about a container by a given name or id..
        /// - Parameter nameOrId: Name or id of a container.
        /// - Throws: Errors that can occur when executing the request.
        /// - Returns: Returns the `Container` and its information.
        public func get(_ nameOrId: String) async throws -> Container {
            return try await client.run(InspectContainerEndpoint(nameOrId: nameOrId))
        }
        
        
        /// Deletes all stopped containers.
        /// - Throws: Errors that can occur when executing the request.
        /// - Returns: Returns an `EventLoopFuture` with a list of deleted `Container` and the reclaimed space.
        public func prune() async throws -> PrunedContainers {
            let response =  try await client.run(PruneContainersEndpoint())
            return PrunedContainers(
                containersIds: response.ContainersDeleted?.map({ .init($0)}) ?? [],
                reclaimedSpace: response.SpaceReclaimed
            )
        }
        
        public struct PrunedContainers {
            /// IDs of the containers that were deleted.
            let containersIds: [String]
            
            /// Disk space reclaimed in bytes.
            let reclaimedSpace: UInt64
        }
    }
}

