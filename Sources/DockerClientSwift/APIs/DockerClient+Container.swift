import Foundation
import NIO
import AsyncHTTPClient

extension DockerClient {
    
    /// APIs related to containers.
    public var containers: ContainersAPI {
        .init(client: self)
    }
    
    public struct ContainersAPI {
        fileprivate var client: DockerClient
        
        /// Fetches all containers in the Docker system.
        /// - Parameter all: If `true` all containers are fetched, otherwise only running containers.
        /// - Throws: Errors that can occur when executing the request.
        /// - Returns: Returns a list of `Container`.
        public func list(all: Bool = false) async throws -> [ContainerSummary] {
            return try await client.run(ListContainersEndpoint(all: all))
        }
        
        /// Creates a new container from a given image. If specified the commands override the default commands from the image.
        /// - Parameters:
        ///   - image: Instance of an `Image`.
        ///   - commands: Override the default commands from the image. Default `nil`.
        /// - Throws: Errors that can occur when executing the request.
        /// - Returns: Returns  a `Container`.
        public func create(image: Image, commands: [String]? = nil) async throws -> String {
            let response = try await client.run(SimpleCreateContainerEndpoint(imageName: image.id.value, commands: commands))
            return response.Id
        }
        
        /// Creates a new container from a fully customizable config.
        /// - Parameters:
        ///   - image:  Custom name for this container. If not set, a random one will be generated by Docker. Must match `/?[a-zA-Z0-9][a-zA-Z0-9_.-]+` (must start with a letter or number, then must only contain letters, numbers, _, ., -)
        /// - Returns: Returns  the created `Container` id.
        public func create(name: String? = nil, spec: ContainerCreate) async throws -> String {
            let response = try await client.run(CreateContainerEndpoint(name: name, spec: spec))
            return response.Id
        }
        
        /// Starts a container. Before starting it needs to be created.
        /// - Parameter container: Instance of a created `Container`.
        /// - Throws: Errors that can occur when executing the request.
        public func start(container: Container) async throws {
            try await client.run(StartContainerEndpoint(containerId: container.id))
        }
        
        /// Stops a container. Before stopping it needs to be created and started..
        /// - Parameter container: Instance of a started `Container`.
        /// - Throws: Errors that can occur when executing the request.
        public func stop(container: Container) async throws {
            try await client.run(StopContainerEndpoint(containerId: container.id))
        }
        
        /// Removes an existing container.
        /// - Parameter container: Instance of an existing `Container`.
        /// - Throws: Errors that can occur when executing the request.
        public func remove(container: Container) async throws {
            try await client.run(RemoveContainerEndpoint(containerId: container.id))
        }
        
        /// Gets the logs of a container.
        /// - Parameters:
        ///   - container: Instance of an `Container`.
        ///   - stdErr: whether to return log lines from the standard error.
        ///   - stdOut: whether to return log lines from the standard output.
        ///   - timestamps: whether to return the timestamp of each log line
        ///   - follow: whether to wait for new logs to become available and stream them.
        ///   - tail: number of last existing log lines to return. Default: all.
        /// - Throws: Errors that can occur when executing the request.
        /// - Returns: Returns  a  sequence of `LogEntry`.
        public func logs(container: Container, stdErr: Bool = true, stdOut: Bool = true, timestamps: Bool = true, follow: Bool = false, tail: UInt? = nil) async throws -> AsyncThrowingStream<DockerLogEntry, Error> {
            let response = try await client.run(
                GetContainerLogsEndpoint(
                    containerId: container.id,
                    stdout: stdOut,
                    stderr: stdErr,
                    timestamps: timestamps,
                    follow: follow,
                    tail: tail == nil ? "all" : "\(tail!)"
                ),
                timeout: follow ? .hours(24) : .seconds(30)
            )
            
            let format = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSSS'Z'"
            let timestampLen = 31 //format.count
            let formatter = DateFormatter()
            formatter.dateFormat = format
            
            return AsyncThrowingStream<DockerLogEntry, Error> { continuation in
                Task {
                    for try await buffer in try await response {
                        var data = Data(buffer: buffer)
                        for var line in data.split(separator: 10 /* ascii 10 = \n */) {
                            if !container.config.tty {
                                line = line.dropFirst(8)
                            }
                            let message = Data(line)
                            guard let string = String(data: message, encoding: .utf8) else {
                                continuation.finish(throwing: DockerLogDecodingError.dataCorrupted)
                                return
                            }
                            //let splat = string.split(separator: " ")
                            
                            
                            let timestampRaw = string.prefix(timestampLen - 1) /*else {
                                continuation.finish(throwing: DockerLogDecodingError.noTimestampFound)
                                return
                            }*/
                            guard let timestamp = formatter.date(from: String(timestampRaw)) else {
                                continuation.finish(throwing: DockerLogDecodingError.timestampCorrupted)
                                return
                            }
                            let logMessage = String(string.suffix(string.count - timestampLen))
                            
                            continuation.yield(
                                DockerLogEntry(source: .stdout, timestamp: timestamp, message: logMessage)
                            )
                        }
                    }
                    continuation.finish()
                }
            }
        }
        
        /// Fetches the latest information about a container by a given name or id..
        /// - Parameter nameOrId: Name or id of a container.
        /// - Throws: Errors that can occur when executing the request.
        /// - Returns: Returns the `Container` and its information.
        public func get(_ nameOrId: String) async throws -> Container {
            return try await client.run(InspectContainerEndpoint(nameOrId: nameOrId))
        }
        
        
        /// Deletes all stopped containers.
        /// - Throws: Errors that can occur when executing the request.
        /// - Returns: Returns an `EventLoopFuture` with a list of deleted `Container` and the reclaimed space.
        public func prune() async throws -> PrunedContainers {
            let response =  try await client.run(PruneContainersEndpoint())
            return PrunedContainers(
                containersIds: response.ContainersDeleted?.map({ .init($0)}) ?? [],
                reclaimedSpace: response.SpaceReclaimed
            )
        }
        
        public struct PrunedContainers {
            /// IDs of the containers that were deleted.
            let containersIds: [String]
            
            /// Disk space reclaimed in bytes.
            let reclaimedSpace: UInt64
        }
    }
}

extension Container {
    /// Starts a container.
    /// - Parameter client: A `DockerClient` instance that is used to perform the request.
    /// - Throws: Errors that can occur when executing the request.
    /// - Returns: Returns an `EventLoopFuture` when the container is started.
    public func start(on client: DockerClient) async throws {
        try await client.containers.start(container: self)
    }
    
    /// Stops a container.
    /// - Parameter client: A `DockerClient` instance that is used to perform the request.
    /// - Throws: Errors that can occur when executing the request.
    /// - Returns: Returns an `EventLoopFuture` when the container is stopped.
    public func stop(on client: DockerClient) async throws {
        try await client.containers.stop(container: self)
    }
    
    /// Removes a container
    /// - Parameter client: A `DockerClient` instance that is used to perform the request.
    /// - Throws: Errors that can occur when executing the request.
    /// - Returns: Returns an `EventLoopFuture` when the container is removed.
    public func remove(on client: DockerClient) async throws {
        try await client.containers.remove(container: self)
    }
}
